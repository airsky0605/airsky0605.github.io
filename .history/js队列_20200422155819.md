今天正好看到有一个朋友在问一个js队列的问题就想到了之前的一种处理方式.

理想情况下的js函数执行都是都是有序调用。如下。

```
function fn1(){ 
  console.log('output 1')
}
function fn2(){ 
  console.log('output 2')
}
function fn3(){ 
  console.log('output 3')
}
const stack = [fn1,fn2,fn3]
stack.forEach(item => { 
  item()
})
// 输出 output 1 output 2 output 3
```

但是正常的业务 肯定是不会给你这么舒服的调用方式。中间我们肯定会夹杂有一些api请求异步操作，这种时候可能就是这种效果

```
function fn1(){ 
  console.log('output 1')
}
function fn2 () { 
  setTimeout(() => {
    console.log('output 2')
  }, 1000);
}
function fn3(){ 
  console.log('output 3')
}
const stack = [fn1,fn2,fn3]
stack.forEach(item => { 
  item()
})
// 输出 output 1 output 3 output 2(延迟出来)

```
远远达不到理想的 输出123的效果，这个时候我们就得对这种函数进行一种改变。

我们假设本身是在一个栈里面，当前仅当每个当前函数执行结束的时候的就去调用下一个。那么我们定义一个next函数。   
每次通过next函数去获取下一个要执行的函数，每调用一次index自增1，这样就可以每次都会执行到下一步。   
代码如下

```
let i = 0
function next () {
  let _fn = stack[i]
  i++
  if (typeof _fn === 'function') {
    _fn()
   }
}
function fn1(){ 
  console.log('output 1')
  next()
}
function fn2 () { 
  setTimeout(() => {
    console.log('output 2')
    next()
  }, 1000);
}
function fn3(){ 
  console.log('output 3')
  next()
}
const stack = [fn1,fn2,fn3]
next()

```
当然这样的改动可能会对你当前代码的逻辑多多少少有点变动，但我想 应该变化不大。



